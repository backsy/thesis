---
title: "WIP"
author: "Karl Uibo"
date: "11 märts 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::knit_engines$set(python = reticulate::eng_python)
library(reticulate)
```

## Stuff done

installisin mavpython jubina [githubist](https://github.com/ArduPilot/pymavlink) ja seal kasutades mavlogdump.py file käsuga `$ python mavlogdump.py 16.BIN --format json > log `et saada json logist

sama käsk aga panin format csv ja --type BARO > log.csv sain csv kogu baro pakettidest

See json ei osanud rstudiosse lugeda, vb peab jamama veel või ongi csv parem mõte

CSV lugemine failis kuni salvestasin CSV notepadiga nii et muutsin encodingu UTF-8 peale - siis töötas.

uurisin palju mul on neid bin file
```{python}
# -*- coding: utf-8 -*-
import os
import collections
extensions = collections.defaultdict(int)
size = collections.defaultdict(int)

for path, dirs, files in os.walk('E:\\Logid Marguse arvutist'):
   for filename in files:
       extensions[os.path.splitext(filename)[1].lower()] += 1
       size[os.path.splitext(filename)[1].lower()] += os.path.getsize(path+os.sep+filename)

for key,value in extensions.items():
    print 'Extension: ', key, ' ', value, ' items'

for key,value in size.items():
    print 'Extension: ', key, ' ', value, ' size'
```


proovin jsoniga miskit peale hakata, Juhend on lehelt https://blog.exploratory.io/working-with-json-data-in-very-simple-way-ad7ebcc0bb89
Alustuseks tuleb encoding õra muuta. Panin UTF-8 peale kogu jutu ja nii sai file ka palju väiksem. Võibolla saab seda teha jsonisse convertides kuidagi.
```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
library(jsonlite)
json <- stream_in(file("log2.json"))
flatjson <- flatten(json)

```

proovin saada kõik erinevad paketitüübid eraldi
```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
for (i in unique(flatjson$meta.type)) {
  test <- flatjson[flatjson$meta.type == i,]
  assign(i,test)
}
```
BAM

## Mõtted

Ma mõtlen, et pmst nurkade info järgi peaks saama kätte tuule mõjutuse. GPS on vast ka vaja ja baro ehk. Kui võtta, et kopter kohapeal ja muul ajal ka võitleb gravitatsiooni vastu siis õks vektor tuleb sellest. Teine vektor on lennu suunast. Nendest kahest kokku tuleb resultaat vektor, mis ideaalselt ilma tuuleta oleks alati sama. 

* Kas saab arvutada tuuleta vektori datast?
* Kas saab leida mõjutava vektori?
* Kas tuleks keskmestada või vaadata märasemat infot?

## Reede 30.03

Proovisin uuesti jsonisse lugeda logi. Tegin `python C:\Python27\Scripts\mavlogdump.py 44.BIN --format json > 44.json` See logi on 133MB suur ja see json on 1.8 giga... Teine idee oli kasutada `mavtomfile.py`scripti: `python C:\Python27\Scripts\mavtomfile.py 44.BIN` ja selle output oli file `m_44.m` mille suurus on 592MB.

See m-file on paljulubav ja mõtlen selle järgi teha oma koodi mis loeb datat sisse. Alustan 50 rea kaupa lugemist. Panen sellega kogu süsteemi tööle ja siis saan laieneda terve logi peale.

Kuna ma m-file ei saanud ilusti sisse lugeda ja see pythoni script mis seda töötlust teeb on lihtne otsustasin selle baasil kirjutada koodi mis transleerib selle bin file mulle sobivale kujule. Otsisin erinevaid formaate ja andmebaase ja valisin välja sqlite andmebaasi mis pole justkui täis andmebaas ja on mõeldud lokaalse filesüsteemi jaoks ent samas on natuke ka andmebaas ja andmebaasi liideste kaudu suudab R sellega suhelda. Kuna on andmebaas-lite see sqlite siis vajadusel või soovil saan hiljem ka liigutada kogu krempil lihtsalt päris andmebaasi süsteemi.

Tegin nii, et tegin pythonig sqlite andmebaasi ja proovisin et saan sinna data kirjutatud. Kood on selline:
<!-- ```{python} -->
<!-- import sqlite3 -->
<!-- conn = sqlite3.connect('example.db') -->
<!-- c = conn.cursor() -->

<!-- # Create table -->
<!-- c.execute('''CREATE TABLE stocks -->
<!--              (date text, trans text, symbol text, qty real, price real)''') -->

<!-- # Insert a row of data -->
<!-- c.execute("INSERT INTO stocks VALUES ('2006-01-05','BUY','RHAT',100,35.14)") -->

<!-- # Save (commit) the changes -->
<!-- conn.commit() -->

<!-- # We can also close the connection if we are done with it. -->
<!-- # Just be sure any changes have been committed or they will be lost. -->
<!-- conn.close() -->

<!-- conn = sqlite3.connect('example.db') -->
<!-- c = conn.cursor() -->

<!-- # Never do this -- insecure! -->
<!-- symbol = 'RHAT' -->
<!-- c.execute("SELECT * FROM stocks WHERE symbol = '%s'" % symbol) -->

<!-- # Do this instead -->
<!-- t = ('RHAT',) -->
<!-- c.execute('SELECT * FROM stocks WHERE symbol=?', t) -->
<!-- print c.fetchone() -->

<!-- # Larger example that inserts many records at a time -->
<!-- purchases = [('2006-03-28', 'BUY', 'IBM', 1000, 45.00), -->
<!--              ('2006-04-05', 'BUY', 'MSFT', 1000, 72.00), -->
<!--              ('2006-04-06', 'SELL', 'IBM', 500, 53.00), -->
<!--             ] -->
<!-- c.executemany('INSERT INTO stocks VALUES (?,?,?,?,?)', purchases) -->

<!-- for row in c.execute('SELECT * FROM stocks ORDER BY price'): -->
<!--   print row -->

<!-- ``` -->
Järgmine samm on lugeda see andmebaas sisse R'iga.

# ```{r, warning=FALSE, message=FALSE}
# library(DBI)
# 
# # Connect/create to/a database
# con <- dbConnect(RSQLite::SQLite(), 'example.db')
# 
# # List tables
# dbListTables(con)
# 
# # Define query
# res <- dbSendQuery(con, "SELECT * FROM stocks ORDER BY price")
# 
# # Execute query
# result <- dbFetch(res)
# 
# # Clear the result
# dbClearResult(res)
# 
# # Disconnect from the database
# dbDisconnect(con)
# ```

Ja `result` sisaldab andmebaasi.

Iga table nimi tuleb otse logist endast ja kuna sql ei luba oma käsus sisestada dünaamilist nime tuli kirjutada jupp koodi, mis puhastab table nime ebasobivatest sümbolitest ning sisestab selle käsu stringi sisse.
<!-- ```{python} -->
<!-- import sqlite3 -->
<!-- conn = sqlite3.connect('example.db') -->

<!-- # scrub the table name so injection attacks wont work -->
<!-- def scrub(table_name): -->
<!--     return ''.join( chr for chr in table_name if chr.isalnum() ) -->

<!-- c = conn.cursor() -->
<!-- table = 'test5' -->
<!-- statement = 'CREATE TABLE {0} (date text, trans text, symbol text, qty real, price real,)'.format(scrub(table)) -->
<!-- c.execute(statement) -->
<!-- query = "INSERT INTO {0} VALUES ('2006-01-05','BUY','RHAT',100,35.14)".format(scrub(table)) -->
<!-- c.execute(query) -->

<!-- conn.commit() -->
<!-- conn.close() -->
<!-- ``` -->

Nii sai lisatud andmebaasi mitu test tabelit enne kui rahule jäin.

Selleks et logides oleks alati unique identifier logide jaoks siis peaks panema ühe table mis sisaldab jk nrit. See ilmselt võiks olla mingi indeks vms. Praegu ei tea, pean kuskilt uurima. Hetkel loen sisse ühe logi, et saaksin midagi edasi teha. 


```{python}
#testin kuidas *args kasutada

list = ['one', 'two', 'three', 'four']
print('a string with words: {0} {1} {2} {3}'.format(*list))


```

Testin kuidas luua table dünaamiliselt nende tulba nimedega, mis logist tulevad ja kuidas lisada data ridasid.

```{python}
import sqlite3
conn = sqlite3.connect('example.db')
c = conn.cursor()

# scrub the text so injection attacks wont work
def scrub(text):
    return ''.join( chr for chr in text if chr.isalnum() )

# Create new table
mtype = 'PRM'
columnHeader = ['date', 'trans', 'symbol', 'qty', 'price']
headersWithType = ','.join( map( lambda  x: str(x) + ' real', columnHeader ) )
statement = 'CREATE TABLE IF NOT EXISTS {0} ({1})'.format( scrub( mtype ), headersWithType )
c.execute(statement)

# Insert data to the table
values = [10,11,12,15,65]
questionmarks = ','.join(map(lambda x: '?', values))
query = 'INSERT INTO {0} VALUES ({1})'.format(scrub(mtype), questionmarks)
c.execute(query, values)
             
conn.commit()
conn.close()
    
```

IpmortLog.py oli üli aeglane ja ma pidin seda hakkama optimeerima. Seda teen nii, et hoian igat tablet mälus 1000 rida ja siis kirjutan kettale. Number võib ka mingi muu olla. Peaks benchmarkima. Praegu probleem jääb, et kui on file lõpp siis poolikud tabled jäevad andmebaasi kirjutamata.


## 11.04
Hakkan Ri importima saadut datat. Toon alustuseks ühe logi.

```{r, warning=FALSE, message=FALSE}
library(DBI)

# Connect/create to/a database
con <- dbConnect(RSQLite::SQLite(), 'test.db')

# List tables
dbListTables(con)

# Define query
res <- dbSendQuery(con, "SELECT * FROM flight")
# Execute query
flights <- dbFetch(res)
dbClearResult(res)
res <- dbSendQuery(con, "SELECT * FROM message")
messages <- dbFetch(res)
dbClearResult(res)
res <- dbSendQuery(con, "SELECT * FROM timestamp")
timestamps <- dbFetch(res)
dbClearResult(res)
res <- dbSendQuery(con, "SELECT * FROM parameter")
parameters <- dbFetch(res)
dbClearResult(res)
res <- dbSendQuery(con, "SELECT * FROM value")
values <- dbFetch(res)

# Clear the result
dbClearResult(res)

# Disconnect from the database
dbDisconnect(con)
```

```{r, warning=FALSE, message=FALSE}
library(datamodelr)
library(DiagrammeR)

dm_f <- dm_from_data_frames(flights, messages, timestamps, parameters, values)
dm_f <- dm_add_references(
  dm_f,
  values$flight == flights$id,
  values$message == messages$id,
  values$timestamp == timestamps$id,
  values$parameter == parameters$id
)
graph <- dm_create_graph(dm_f, rankdir = "BT", col_attr = c("column", "type"))
dm_render_graph(graph)
```















